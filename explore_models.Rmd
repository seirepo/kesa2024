---
title: "R Notebook"
output: html_notebook
---

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

```{r}
setwd("/scratch/dongelr1/susannar/kesa2024")

library(dplyr)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(tidyr)
library("scales")
library(purrr)
library('stringr')
library(corrplot)
library(RColorBrewer)
```


```{r}
dat <- read.csv("data/all_data_merged.csv", stringsAsFactors = FALSE)
dat$Time <- ymd_hms(dat$Time, tz = "UTC", truncated = 3)

# Drop all na rows and filter out times when it's too dark
dat_filtered <- drop_na(dat) %>% filter(global_radiation > 10 & SO2 > 0.1)

```

Generic correlation matrix of the data

```{r}

test_df <- select(dat, -Time)
corr <- cor(x = test_df, use = "pairwise.complete.obs")

corrplot(corr, method = "number")#, type = "upper")
corrplot(corr, method = "color", order = "alphabet")
corrplot(corr)
corrplot(corr, method = "ellipse")#, type = "upper")
```


## Replicate plots from A statistical proxy for sulphuric acid concentration

For each year, try to replicate plots in the paper A statistical proxy for sulphuric acid concentration.
TODO:
- Use the same data filtering: pick only observations where global_radiation > 10 and SO2 > 0.1
- Recreate some of the tables/plots in the paper
- Try out the linear models described in the paper

```{r}

ggplot(dat_filtered, aes(x = CS_rate, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + facet_wrap(~year(Time)) + ggtitle("Filtered with global radiation > 10 and SO2 > 0.1")

dat_filtered %>% mutate(CS_RH = dat_filtered$CS_rate * dat_filtered$relative_humidity) %>% ggplot(aes(x = CS_RH, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") + facet_wrap(~year(Time)) + ggtitle("Filtered with global radiation > 10 and SO2 > 0.1")

```


Average daily changes in scaled variables, by hour (Fig. 4)

```{r}
  
get_scaled_hourly_averages <- function(df) {
  dat_mutated <- df %>% mutate(CS_RH_inv = 50 * 1/(df$CS_rate * df$relative_humidity)) %>% mutate(CS_inv = 1/CS_rate) %>% mutate(SA_scaled = SA_cm3 / 1e4)
  
  SA_scaled <- dat_mutated %>%
    dplyr::group_by(hour(Time)) %>%
    dplyr::summarize(
      SA_scaled_av = mean(SA_scaled, na.rm = TRUE)
    )
  
  CS_inv <- dat_mutated %>%
    dplyr::group_by(hour(Time)) %>%
    dplyr::summarize(
      CS_inv_av = mean(CS_inv, na.rm = TRUE)
    )
  
  CS_RH_inv <- dat_mutated %>%
    dplyr::group_by(hour(Time)) %>%
    dplyr::summarize(
      CS_RH_inv_av = mean(CS_RH_inv, na.rm = TRUE)
    )
  
  gr <- dat_mutated %>%
    dplyr::group_by(hour(Time)) %>%
    dplyr::summarize(
      gr_av = mean(global_radiation, na.rm = TRUE)
    )
  
  r <- Reduce(function(x, y) merge(x, y, by = "hour(Time)"), list(SA_scaled, CS_inv, CS_RH_inv, gr))
  names(r)[names(r) == "hour(Time)"] <- "hour"
  return(r)
}

d12 <- filter(dat, year(Time) == 2012)
r <- get_scaled_hourly_averages(d12)

plot_scaled_hourly_averages <- function(df, year = "") {
  p <- ggplot(df, aes(hour)) +
    geom_line(aes(y = SA_scaled_av, colour = "SA 10^4"), na.rm = TRUE) +
    geom_line(aes(y = CS_inv_av, colour = "CS^-1"), na.rm = TRUE) +
    geom_line(aes(y = CS_RH_inv_av, colour = "50 * (CS * RH)^-1"), na.rm = TRUE) +
    geom_line(aes(y = gr_av, colour = "global_radiation"), na.rm = TRUE) +
    ylab("") +
    ggtitle(year)
}


dat_year <- split(dat_filtered, year(dat_filtered$Time))
l <- lapply(dat_year, get_scaled_hourly_averages)
# plot_list <- lapply(l, plot_scaled_hourly_averages)

plotlist <- list()
for (i in 1:length(l)) {
  p <- plot_scaled_hourly_averages(df = l[[i]], year = names(l)[[i]])
  plotlist[[i]] <- p
}

p1 <- ggarrange(plotlist = plotlist, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p1

d18 <- filter(dat_filtered, year(Time) == 2018)
av18 <- get_scaled_hourly_averages(d18)
p <- plot_scaled_hourly_averages(av18) + ggtitle("2018") + ylab("")
p

```

Check how the data that is filtered out from the actual dataset is distributed during the day

```{r}
hourly_sa_data <- function(df) {
  sa <- df %>%
    dplyr::group_by(hour(Time)) %>%
    dplyr::summarize(
      count = n()
    )

  names(sa)[names(sa) == "hour(Time)"] <- "hour"
  return(sa)
}

get_barplot <- function(df, title) {
  p <- ggplot(df, aes(x = hour, y = count)) +
    geom_bar(stat = "identity") +
    labs(title = title,
         x = "hour",
         y = "SA count") +
    # scale_x_discrete(breaks = seq(0, 23, by = 1)) +
    scale_x_continuous(breaks = seq(0, 23, by = 1)) +
    # scale_x_discrete(breaks = as.character(0:23)) +
    scale_y_continuous(limits = c(0, 1500), breaks = seq(0, 1500, by = 500))
}

# Check the distribution of data with the values filtered out
dat_rest <- drop_na(dat) %>% filter(global_radiation <= 10 | SO2 <= 0.1)
dat_gr_leftover <- drop_na(dat) %>% filter(global_radiation <= 10)
dat_so2_leftover <- drop_na(dat) %>% filter(SO2 <= 0.1)
# dat_complete_leftover <- drop_na(dat) %>% filter(global_radiation <= 10 & SO2 <= 0.1)


plotlist <- list(
  p1 <- hourly_sa_data(dat_rest) %>% get_barplot(title = "global_radiation <= 10 or SO2 <= 0.1"),
  p2 <- hourly_sa_data(dat_gr_leftover) %>% get_barplot(title = "global_radiation <= 10"),
  p3 <- hourly_sa_data(dat_so2_leftover) %>% get_barplot(title = "SO2 <= 0.1"),
  # p5 <- dat %>% drop_na %>% hourly_sa_data() %>% get_barplot(title = "unfiltered data"),
  p6 <- hourly_sa_data(dat_filtered) %>% get_barplot(title = "global radiation > 10 and SO2 > 0.1 (this is what we are using)")
)

p <- ggarrange(plotlist = plotlist, common.legend = TRUE, nrow = 2, ncol = 3, legend = "bottom")
p
```


Create a summary table similar to Table 2

```{r}
dat_mutated <- dat_filtered %>% mutate(SA_scaled = SA_cm3/1e6) %>% mutate(CS_scaled = (CS_rate * 10^3))

av <- dat_mutated %>% select(-Time) %>%
  summarise_at(colnames(.), mean, na.rm = TRUE)
rownames(av)[1] <- "mean"

std <- dat_mutated %>% select(-Time) %>%
  summarise_at(colnames(.), sd, na.rm = TRUE)
rownames(std)[1] <- "sd"

med <- dat_mutated %>% select(-Time) %>%
  summarise_at(colnames(.), median, na.rm = TRUE)
rownames(med)[1] <- "median"

p5 <- dat_mutated %>% select(-Time) %>%
  summarise_at(colnames(.), quantile, probs = 0.05, na.rm = TRUE)
rownames(p5)[1] <- "5 % percentile"

p95 <- dat_mutated %>% select(-Time) %>%
  summarise_at(colnames(.), quantile, probs = 0.95, na.rm = TRUE)
rownames(p95)[1] <- "95 % percentile"

tot_summary <- rbind(av, med, p5, p95, std)
tot_summary <- tot_summary %>% mutate_all(~ round(., 2))
#tot_summary %>% select(-air_pressure, -temperature, -NOx, -wind_direction, -wind_speed, -wdir_sin, -wdir_cos, -SA_cm3, -CS_rate, -ToL, -sector)
# tot_summary[, c("SA_scaled" , "SO2" , "CS_scaled" , "global_radiation" , "relative_humidity" , "O3" , "temperature_K")]
tot_summary <- tot_summary %>% dplyr::select(SA_scaled, SO2, CS_scaled, global_radiation, relative_humidity, O3, temp_K)
summary_table <- as.data.frame(t(tot_summary))
summary_table
```

Plot a scatter plot of SA and all the proxies

```{r}
# Add column for the reaction rate k
calc_reaction_rate <- function(dat) {
  M <- 0.101 * (1.381 * 1e-23 * dat$temp_K)^-1
  k1 <- 4e-31
  k2 <- 3.3
  k3 <- 2e-12
  k5 <- -0.8
  A <- k1 * M * (300 / dat$temp_K)^k2
  
  k <- A * k3 / (A + k3) * exp(k5 * (1 + log10(A / k3)^2)^-1)
  dat <- dat %>% mutate(k = k)
  return(dat)
}

dat_filtered <- calc_reaction_rate(dat_filtered)

dat_features <- dat_filtered %>% mutate(x1 = k * global_radiation * SO2 / CS_rate) %>%
  mutate(x2 = k * global_radiation * SO2) %>%
  mutate(x3 = k * global_radiation * SO2^0.5) %>%
  mutate(x4 = k * global_radiation * SO2 / relative_humidity) %>%
  mutate(x5 = k * global_radiation * SO2 / (CS_rate * relative_humidity))

plots <- list(
  p1 <- ggplot(dat_features, aes(x = x1, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
    xlab("k * global_radiation * SO2 / CS_rate") + ggtitle(paste("L1: Corr", round(cor(x = dat_features$x1, y = dat_features$SA_cm3), 4))),
  p2 <- ggplot(dat_features, aes(x = x2, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
    xlab("k * global_radiation * SO2") + ggtitle(paste("L2: Corr", round(cor(x = dat_features$x2, y = dat_features$SA_cm3), 4))),
  p3 <- ggplot(dat_features, aes(x = x3, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
    xlab("k * global_radiation * SO2^0.5") + ggtitle(paste("L3: Corr", round(cor(x = dat_features$x3, y = dat_features$SA_cm3), 4))),
  p4 <- ggplot(dat_features, aes(x = x4, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
    xlab("k * global_radiation * SO2 / RH") + ggtitle(paste("L4: Corr", round(cor(x = dat_features$x4, y = dat_features$SA_cm3), 4))),
  p5 <- ggplot(dat_features, aes(x = x5, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
    xlab("k * global_radiation * SO2 / (RH * CS_rate)") + ggtitle(paste("L5: Corr", round(cor(x = dat_features$x5, y = dat_features$SA_cm3), 4)))
)

p <- ggarrange(plotlist = plots, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p

# test <- dat_features %>% mutate(color = case_when(
#   month(Time) %in% c(1, 2, 12) ~ "lightblue", # winter
#   month(Time) %in% c(3, 4, 5) ~ "lightgreen", # spring
#   month(Time) %in% c(6, 7, 8) ~ "pink",       # summer
#   month(Time) %in% c(9, 10, 11) ~ "orange"#,  # autumn
#   #global_radiation < 50 ~ "grey"
#   #TRUE ~ "black"
# ))

# ggplot(test, aes(x = x5, y = SA_cm3, color = color)) +
#   geom_point() +
#   scale_color_identity() +  # Use the color as is
#   scale_x_continuous(trans = 'log10') +  # Log scale for x-axis if needed
#   scale_y_continuous(trans = 'log10') #+  # Log scale for y-axis if needed

# ggplot(dat_features, aes(x = x4, y = SA_cm3)) + geom_point(na.rm = TRUE, shape = 1) + scale_y_continuous(trans = "log10") + scale_x_continuous(trans = "log10") +
#     xlab("k * global_radiation * SO2 / RH") + ggtitle(paste("L4: Corr", round(cor(x = dat_features$x4, y = dat_features$SA_cm3), 4)))

```


Plot the metrics of the model trained on the filtered dataset

```{r}
plot_scores <- function(data, metric, title = "") {
  data$score[data$scoreType == "RMSE"] <- data$score[data$scoreType == "RMSE"] / 1e6
  
  data <- subset(data, scoreType == metric)
  breaks <- seq(0, max(data$score), 1)
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  }
  
  if (metric == "RMSE") {
    title <- paste(title, "1e6")
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  print("Test train split done")
  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

#color_palette <- brewer.pal(n = 9, name = "Pastel2")
color_palette <- brewer.pal(n = 9, name = "Set3")

load("/scratch/dongelr1/susannar/kesa2024/model_script_score_df.RData")

p1 <- plot_scores(score_df, "R2")
p2 <- plot_scores(score_df, "RMSE", "1e6")

p1
p2

p <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
p
```

Plot scores of models

```{r}
path = "/scratch/dongelr1/susannar/kesa2024/model_script_score_df.RData"
load(file = path)

p1 <- plot_scores(score_df, "R2")
p2 <- plot_scores(score_df, "RMSE", "1e6")

p <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
p
```
Scores when the NAs are removed from the dataset after they have been splitted to the model, instead of removing all NAs before splitting the dataset to separate models
```{r}
path = "/scratch/dongelr1/susannar/kesa2024/model_script_score_df_na_sep.RData"
load(file = path)

p1 <- plot_scores(score_df, "R2")
p2 <- plot_scores(score_df, "RMSE", "1e6")

p <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
p
```


Check what kind of observations were filtered out by requiring global_radiation > 10 and SO2 > 0.1. Basic linear model with filtered data and all features results in R^2 of approx. 0.35 while the one with unfiltered data with approx 0.05
```{r}
dat <- read.csv("data/all_data_merged.csv", stringsAsFactors = FALSE)
dat$Time <- ymd_hms(dat$Time, tz = "UTC", truncated = 3)
dat_filtered <- drop_na(dat) %>% filter(global_radiation > 10 & SO2 > 0.1)

ggplot(dat_filtered, aes(y = SA_cm3)) + geom_boxplot(outlier.size=4, na.rm=TRUE) + facet_wrap(~year(Time)) + scale_y_continuous(trans = "log10")

#dat_rest <- drop_na(dat) %>% filter(global_radiation < 10 | SO2 < 0.1)
dat_rest <- dat %>% filter(global_radiation < 10 | SO2 < 0.1)
ggplot(dat_rest, aes(y = SA_cm3)) + geom_boxplot(outlier.size = 4) + facet_wrap(~year(Time)) + scale_y_continuous(trans = "log10")

#dat_merged <- merge(dat_filtered[,c("Time", "SA_cm3")], dat_rest[,c("Time", "SA_cm3")], by = "Time", all = TRUE)
dat_merged <- merge(dat_filtered[,c("Time", "SA_cm3")], dat[,c("Time", "SA_cm3")], by = "Time", all = TRUE)
names(dat_merged)[names(dat_merged) == "SA_cm3.x"] <- "SA_cm3_filtered"
names(dat_merged)[names(dat_merged) == "SA_cm3.y"] <- "SA_cm3_unfiltered"

merged_long <- dat_merged %>%
  pivot_longer(cols = starts_with("SA_cm3"), names_to = "variable", values_to = "value")

ggplot(merged_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  facet_wrap(~ year(Time), scales = "free_y") +
  labs(title = "Differences between the filtered and non-filtered values",
       x = "Data",
       y = "SA_cm3") +
  theme_minimal() +
  scale_y_continuous(trans = "log10")

```

All observations from 2011 get filtered out, why

```{r}
dat <- read.csv("data/all_data_merged.csv", stringsAsFactors = FALSE)
dat$Time <- ymd_hms(dat$Time, tz = "UTC", truncated = 3)

dat11_f <- dat %>% filter(global_radiation > 10 & SO2 > 0.1 & year(Time) == 2011)
#dat11 <- filter(dat_filtered, year(Time) == 2011 & !is.na(SA_cm3)) %>% select(Time, SA_cm3, global_radiation, SO2, CS_rate, relative_humidity)


dat11 <- dat %>% filter(year(Time) == 2011 & !is.na(SA_cm3)) %>% select(Time, SA_cm3, global_radiation, SO2, CS_rate, relative_humidity)

long11 <- dat11 %>%
  pivot_longer(cols = c("SA_cm3", "global_radiation", "SO2", "CS_rate", "relative_humidity"), names_to = "variable", values_to = "value")


stat_box_data <- function(x) {
  # r <- data.frame(y = mean(x, na.rm = TRUE) + 2 * sd(x, na.rm = TRUE), label = paste(length(x)))
  r <- data.frame(y = max(x, na.rm = TRUE) + sd(x, na.rm = TRUE), label = paste(length(x)))
  return(r)
}

plot_features <- function(df, title) {
  df_long <- df %>%
    pivot_longer(cols = c("SA_cm3", "global_radiation", "SO2", "CS_rate", "relative_humidity"), names_to = "variable", values_to = "value")

  p <- ggplot(df_long, aes(x = variable, y = value, fill = variable)) +
    geom_boxplot(na.rm = TRUE) +
    ggtitle(title) +
    stat_summary(fun.data = stat_box_data, geom = "text", fun = log,
                    position = position_dodge(width = 0.75)) +
    scale_y_continuous(trans = "log10")
  return(p)
}

plot_features(dat11_f, "Features in 2011 with # of observations, filtered")
plot_features(dat11, "Features in 2011 with # of observations when SA is not NA")

```

Because there's no SO2 data during the time from which there is SA data

```{r}
dual_plot <- function(data, second_col) {
  
  # Scaling factor for the second axis
  range_sa <- range(data$SA_cm3, na.rm = TRUE)
  range_rh <- range(data[,3], na.rm = TRUE)
  scale_factor <- diff(range_sa) / diff(range_rh)
  data <- data %>%
    mutate(rh_scaled = .[,3] * scale_factor)
  
  p <- ggplot(data) +
    geom_point(aes(x = Time, y = SA_cm3), shape = 1, na.rm = TRUE) +
    geom_point(aes(x = Time, y = rh_scaled), color = "lightblue", shape = 1, na.rm = TRUE) +
    scale_y_continuous(
      name = "SA",
      sec.axis = sec_axis(~ . / scale_factor, name = second_col)
    ) +
    theme_minimal()
  return(p)
}


data <- dat %>% filter(year(Time) == 2011) %>% select(Time, SA_cm3, SO2)
p1 <- dual_plot(data, "SO2")
data <- dat %>% filter(year(Time) == 2011) %>% select(Time, SA_cm3, global_radiation)
p2 <- dual_plot(data, "global_radiation")
data <- dat %>% filter(year(Time) == 2011) %>% select(Time, SA_cm3, relative_humidity)
p3 <- dual_plot(data, "relative_humidity")
data <- dat %>% filter(year(Time) == 2011) %>% select(Time, SA_cm3, CS_rate)
p4 <- dual_plot(data, "CS_rate")

p <- ggarrange(plotlist = list(p1, p2, p3, p4), common.legend = TRUE, nrow = 2, ncol = 2, legend = "bottom")
p

dat %>% filter(year(Time) == 2011 & !is.na(SA_cm3) & !is.na(SO2))
```



Inspect fits of yearly data (trained with reaction rate k in the training data)

```{r}
path = "/scratch/dongelr1/susannar/kesa2024/lm_score_df_yearly.RData"
load(path)

names(scores_all)[names(scores_all) == "score_type"] <- "scoreType"
names(scores_all)[names(scores_all) == "proxy"] <- "type"
#scores_all <- scores_all %>% mutate(model = "lm")
scores_all$score[scores_all$scoreType == "RMSE"] <- scores_all$score[scores_all$scoreType == "RMSE"] / 1e6
scores_all <- scores_all %>% filter(type %in% c("L1", "L2", "L3", "L4", "L5"))

# Edit the plotting code such that scores for single model data can be plotted
plot_scores <- function(data, metric, title = "") {
  title <-  unique(data$year)
  data <- subset(data, scoreType == metric)
  breaks <- seq(0, 10, 1)
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  }
  
  if (metric == "RMSE") {
    title = paste("1e6", title, sep = ", ")
  }

  test_data <- subset(data, scoreType == metric & split == "test")
  train_data <- subset(data, scoreType == metric & split == "train")

  p <- ggplot(data = test_data, aes(x = type, y = score)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE), fill = "lightblue") +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    # scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
    #                   breaks = c("rf", "lm")) +
    # guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    # labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

yearly_scores <- split(scores_all, scores_all$year)
#plot_scores(yearly_scores[[2]], "R2")
l1 <- lapply(yearly_scores, plot_scores, metric = "R2")
l2 <- lapply(yearly_scores, plot_scores, metric = "RMSE")


p1 <- ggarrange(plotlist = l1, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p2 <- ggarrange(plotlist = l2, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p1
p2

plot <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
plot

```

Plot a time sequence of some of the transformed features from a short period

```{r}
j18 <- filter(dat, year(Time) == 2018 & month(Time) == 6 & day(Time) %in% seq(1, 7)) %>% select(Time, SA_cm3, global_radiation, SO2, CS_rate, relative_humidity)
# head(j18)

d1 <- mutate(j18, SA_cm3 = SA_cm3 / 1e4) %>% mutate(CS_RH = mean(relative_humidity) * 1/(CS_rate * relative_humidity)) %>% mutate(CS_rate = 1/CS_rate)

long <- d1 %>%
  pivot_longer(cols = c("SA_cm3", "global_radiation", "SO2", "CS_rate", "relative_humidity", "CS_RH"), names_to = "variable", values_to = "value")

p <- ggplot(d1, aes(Time)) +
  geom_line(aes(y = SA_cm3, colour = "SA 10^4"), na.rm = TRUE) +
  geom_line(aes(y = CS_rate, colour = "1/CS"), na.rm = TRUE) +
  # geom_line(aes(y = global_radiation, colour = "global_radiation"), na.rm = TRUE) +
  geom_line(aes(y = CS_RH, colour = "1/(CS*RH)"), na.rm = TRUE) +
  scale_x_datetime(breaks = date_breaks("1 day"), labels = date_format("%d-%m"))
p

range_sa <- range(data$SA_cm3, na.rm = TRUE)
range_rh <- range(data[,3], na.rm = TRUE)
scale_factor <- diff(range_sa) / diff(range_rh)
data <- data %>%
  mutate(rh_scaled = .[,3] * scale_factor)

p <- ggplot(data) +
  geom_point(aes(x = Time, y = SA_cm3), shape = 1, na.rm = TRUE) +
  geom_point(aes(x = Time, y = rh_scaled), color = "lightblue", shape = 1, na.rm = TRUE) +
  scale_y_continuous(
    name = "SA",
    sec.axis = sec_axis(~ . / scale_factor, name = "second_col")
  ) +
  # labs(title = "Point Plot with Dual Y Axes",
  #      x = "Date") +
  theme_minimal()

p
```

Check the scores of models fitted to a shorter time period (trained with reaction rate k in the training data)

```{r}
path = "/scratch/dongelr1/susannar/kesa2024/model_testing/score_df_03_2012.RData"
load(path)

plot_scores <- function(data, metric, title = "") {

  data <- subset(data, scoreType == metric)
  # breaks <- seq(0, max(data$score), length.out = 10)
  breaks <- seq(0, max(data$score), 1)
  # breaks <- seq(0, 10, 1)
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

color_palette <- brewer.pal(n = 9, name = "Set3")

df <- data.frame(score_df)
df$score[df$scoreType == "RMSE"] <- df$score[df$scoreType == "RMSE"] / 1e6

plot_scores(df, "R2")
plot_scores(df, "RMSE")
```

Check scores when adding one year at a time (trained with reaction rate k in the training data)

```{r}
load("/scratch/dongelr1/susannar/kesa2024/model_testing/score_df_all_splitted_data.RData")

years <- c(2012, 2013, 2018, 2019, 2022)

plot_scores <- function(data, metric, title = "") {
  set_num <- unique(data$set)
  set_id <- paste(years[1:set_num], collapse = ", ")
  title <- paste(title, set_id)
  
  data <- subset(data, scoreType == metric)
  
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  } else if (metric == "RMSE") {
    data$score[data$scoreType == "RMSE"] <- data$score[data$scoreType == "RMSE"] / 1e6
    breaks <- seq(0, max(data$score), 1)
    limits <- c(0, max(data$score))
  } else {
    print(paste("Unknown metric", metric))
    break
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

color_palette <- brewer.pal(n = 9, name = "Set3")

set_scores <- split(final_df, final_df$set)

l1 <- lapply(set_scores, plot_scores, metric = "R2")
l2 <- lapply(set_scores, plot_scores, metric = "RMSE", title = "1e6")
p1 <- ggarrange(plotlist = l1, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p2 <- ggarrange(plotlist = l2, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p1
p2


plot <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
plot

```

Check random monthly scores (trained with reaction rate k in the training data)

```{r}
load("/scratch/dongelr1/susannar/kesa2024/model_testing/score_df_month_subset_data.RData")

plot_scores <- function(data, metric, title = "") {
  months <- unlist(unique(data$month))
  yr <- unique(data$year)
  month_title <- paste(months, collapse = ", ")
  title <- paste(title, yr, month_title)
  
  # print(paste(month_seq[[1]][[1]], month_seq[[1]][[3]]))
  # print(title)
  
  data <- subset(data, scoreType == metric)
  
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  } else if (metric == "RMSE") {
    data$score[data$scoreType == "RMSE"] <- data$score[data$scoreType == "RMSE"] / 1e6
    breaks <- seq(0, max(data$score), 1)
    limits <- c(0, max(data$score))
  } else {
    print(paste("Unknown metric", metric))
    break
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

color_palette <- brewer.pal(n = 9, name = "Set3")


subset_scores <- split(final_df, final_df$year)

l1 <- lapply(subset_scores, plot_scores, metric = "R2")
l2 <- lapply(subset_scores, plot_scores, metric = "RMSE", title = "1e6")
p1 <- ggarrange(plotlist = l1, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p2 <- ggarrange(plotlist = l2, common.legend = TRUE, nrow = 3, ncol = 2, legend = "bottom")
p1
p2

```

Plot metrics of models trained on all data except 2013 (trained with reaction rate k in the training data)

```{r}
load("/scratch/dongelr1/susannar/kesa2024/model_testing/score_df_without_2013.RData")

plot_scores <- function(data, metric, title = "") {
  
  data <- data.frame(data)
  data$score[data$scoreType == "RMSE"] <- data$score[data$scoreType == "RMSE"] / 1e6
  
  data <- subset(data, scoreType == metric)
  # breaks <- seq(0, max(data$score), length.out = 10)
  breaks <- seq(0, max(data$score), 1)
  # breaks <- seq(0, 10, 1)
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

color_palette <- brewer.pal(n = 9, name = "Set3")

p1 <- plot_scores(score_df, "R2")
p2 <- plot_scores(score_df, "RMSE")


p <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 1, ncol = 2, legend = "bottom")
p

```

Check scores for models trained on unnormalized data, normalized data and the data that is removed in the filtering process and compare them (trained with reaction rate k in the training data)

```{r}
plot_scores <- function(data, metric, title = "") {
  
  data <- data.frame(data)
  data$score[data$scoreType == "RMSE"] <- data$score[data$scoreType == "RMSE"] / 1e6
  
  data <- subset(data, scoreType == metric)
  breaks <- seq(0, max(data$score), 1)
  # breaks <- seq(0, 10, 1)
  limits <- c(0, max(data$score))
  if (metric == "R2") {
    breaks <- seq(0, 1, 0.25)
    limits <- c(0, 1.05)
  }

  test_data <- subset(data, scoreType == metric & split == "Test")
  train_data <- subset(data, scoreType == metric & split == "Train")

  p <- ggplot(data = test_data, aes(x = type, y = score, fill = model)) +
    geom_bar(stat = "identity", position = "dodge", color = "black", show.legend = c(fill = TRUE)) +
    geom_point(data = train_data, shape = 4, color = "black", aes(x = type, y = score, fill = model), position = position_dodge(0.9), size = 3) +
    scale_y_continuous(breaks = breaks, limits = limits) +
    ggtitle(paste(metric, title)) +
    scale_fill_manual(values = setNames(c(color_palette[5], color_palette[8]), c("rf", "lm")),
                      breaks = c("rf", "lm")) +
    guides(fill = guide_legend(override.aes = list(pattern = c("none", "none")))) +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(panel.border=element_rect(linetype=1, fill=NA)) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.y.right = element_blank(), axis.ticks.y.right = element_blank()) +
    geom_text(aes(label = sprintf("%.2f", score)), position = position_dodge(width = 0.9), vjust = -0.3)

  return(p + theme(legend.position = "bottom"))
}

color_palette <- brewer.pal(n = 9, name = "Set3")

get_metric_plot <- function(path, title) {
  load(path)
  
  p1 <- plot_scores(score_df, "R2")
  p2 <- plot_scores(score_df, "RMSE", "1e6")
  
  rm(score_df)
  
  p <- ggarrange(plotlist = list(p1, p2), common.legend = TRUE, nrow = 2, ncol = 1, legend = "bottom")
  p <- annotate_figure(p, top = text_grob(title))

  return(p)
}

p1 <- get_metric_plot("/scratch/dongelr1/susannar/kesa2024/model_script_score_df.RData", title = "Filtered data")
p2 <- get_metric_plot("/scratch/dongelr1/susannar/kesa2024/model_script_score_df_preprocessed.RData", title = "Filtered and preprocessed data (centered and scaled)")
p3 <- get_metric_plot("/scratch/dongelr1/susannar/kesa2024/model_script_score_df_removed_data.RData", title = "Data removed in the filtering")

p <- ggarrange(plotlist = list(p1, p2, p3), common.legend = TRUE, nrow = 1, ncol = 3, legend = "bottom")
p
```







